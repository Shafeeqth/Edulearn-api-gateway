// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               v3.20.3
// source: user.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { Timestamp } from "./google/protobuf/timestamp";

export const protobufPackage = "user";

/** Common User Information */
export interface UserInfo {
  userId: string;
  username: string;
  email: string;
  firstName: string;
  lastName: string;
  role: string;
  isBlocked: boolean;
  createdAt: Date | undefined;
  updatedAt: Date | undefined;
}

/** Common Pagination Request */
export interface PaginationRequest {
  page: number;
  pageSize: number;
}

/** Common Pagination Response */
export interface PaginationResponse {
  totalItems: number;
  totalPages: number;
}

/** Generic Error Message */
export interface Error {
  /** e.g., "RESOURCE_NOT_FOUND", "INVALID_ARGUMENT", "UNAUTHENTICATED" */
  code: string;
  message: string;
  /** Optional detailed error information */
  details: ErrorDetail[];
}

export interface ErrorDetail {
  field: string;
  message: string;
}

export interface WalletTransaction {
  transactionId: string;
  userId: string;
  amount: number;
  /** e.g., "deposit", "withdrawal", "purchase" */
  type: string;
  transactionDate: Date | undefined;
}

/** Register User */
export interface RegisterUserRequest {
  username: string;
  email: string;
  password: string;
  role: string;
  avatar: string;
  /** e.g., "password", "google", "facebook" */
  authType: string;
}

/** Verify User */
export interface VerifyUserRequest {
  email: string;
}

export interface RegisterUserResponse {
  userId?: string | undefined;
  error?: Error | undefined;
}

/** Login User */
export interface LoginUserRequest {
  email: string;
  password: string;
  /** e.g., "password", "google", "facebook" */
  authType: string;
}

export interface LoginUserResponse {
  success?: LoginSuccess | undefined;
  error?: Error | undefined;
}

export interface VerifyUserResponse {
  success?: VerifySuccess | undefined;
  error?: Error | undefined;
}

export interface LoginSuccess {
  accessToken: string;
  refreshToken: string;
  user: UserInfo | undefined;
}

export interface VerifySuccess {
  accessToken: string;
  refreshToken: string;
  user: UserInfo | undefined;
}

/** Get New Refresh Token */
export interface GetNewRefreshTokenRequest {
  refreshToken: string;
}

export interface GetNewRefreshTokenResponse {
  success?: RefreshSuccess | undefined;
  error?: Error | undefined;
}

export interface RefreshSuccess {
  accessToken: string;
  refreshToken: string;
}

/** Forgot Password */
export interface ForgotPasswordRequest {
  email: string;
}

export interface ForgotPasswordResponse {
  success?: ForgotPasswordSuccess | undefined;
  error?: Error | undefined;
}

export interface ForgotPasswordSuccess {
  acknowledged: boolean;
}

/** Update User Details */
export interface UpdateUserDetailsRequest {
  userId: string;
  firstName: string;
  /** Add other fields that can be updated */
  lastName: string;
}

export interface UpdateUserDetailsResponse {
  user?: UserInfo | undefined;
  error?: Error | undefined;
}

/** Change Password */
export interface ChangePasswordRequest {
  userId: string;
  oldPassword: string;
  newPassword: string;
}

export interface ChangePasswordResponse {
  success?: ChangePasswordSuccess | undefined;
  error?: Error | undefined;
}

export interface ChangePasswordSuccess {
  updated: boolean;
}

/** Get Wallet Transactions */
export interface GetWalletTransactionsRequest {
  userId: string;
  pagination: PaginationRequest | undefined;
}

export interface GetWalletTransactionsResponse {
  success?: WalletTransactionsSuccess | undefined;
  error?: Error | undefined;
}

export interface WalletTransactionsSuccess {
  transactions: WalletTransaction[];
  pagination: PaginationResponse | undefined;
}

/** Get All Users */
export interface GetAllUsersRequest {
  pagination: PaginationRequest | undefined;
}

export interface GetAllUserEmailsRequest {
  pagination: PaginationRequest | undefined;
}

export interface GetAllUsersResponse {
  success?: AllUsersSuccess | undefined;
  error?: Error | undefined;
}

export interface GetAllUserEmailsResponse {
  success?: AllUserEmailsSuccess | undefined;
  error?: Error | undefined;
}

export interface AllUserEmailsSuccess {
  email: string[];
}

export interface AllUsersSuccess {
  users: UserInfo[];
  pagination: PaginationResponse | undefined;
}

/** Get User By ID */
export interface GetUserByIdRequest {
  userId: string;
}

export interface CheckUserByEmailRequest {
  email: string;
}

export interface EmailExist {
  success: string;
  error: string;
}

export interface CheckUserByEmailResponse {
  response?: EmailExist | undefined;
  error?: Error | undefined;
}

export interface GetUserByIdResponse {
  user?: UserInfo | undefined;
  error?: Error | undefined;
}

/** Block User */
export interface BlockUserRequest {
  userId: string;
}

export interface BlockUserResponse {
  success?: BlockUserSuccess | undefined;
  error?: Error | undefined;
}

export interface BlockUserSuccess {
  updated: boolean;
}

/** Get All Instructors */
export interface GetAllInstructorsRequest {
  pagination: PaginationRequest | undefined;
}

export interface GetAllInstructorsResponse {
  success?: AllInstructorsSuccess | undefined;
  error?: Error | undefined;
}

export interface AllInstructorsSuccess {
  instructors: UserInfo[];
  pagination: PaginationResponse | undefined;
}

function createBaseUserInfo(): UserInfo {
  return {
    userId: "",
    username: "",
    email: "",
    firstName: "",
    lastName: "",
    role: "",
    isBlocked: false,
    createdAt: undefined,
    updatedAt: undefined,
  };
}

export const UserInfo: MessageFns<UserInfo> = {
  encode(message: UserInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.username !== "") {
      writer.uint32(18).string(message.username);
    }
    if (message.email !== "") {
      writer.uint32(26).string(message.email);
    }
    if (message.firstName !== "") {
      writer.uint32(34).string(message.firstName);
    }
    if (message.lastName !== "") {
      writer.uint32(42).string(message.lastName);
    }
    if (message.role !== "") {
      writer.uint32(50).string(message.role);
    }
    if (message.isBlocked !== false) {
      writer.uint32(56).bool(message.isBlocked);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(66).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.firstName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.lastName = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.role = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.isBlocked = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserInfo {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      firstName: isSet(object.firstName) ? globalThis.String(object.firstName) : "",
      lastName: isSet(object.lastName) ? globalThis.String(object.lastName) : "",
      role: isSet(object.role) ? globalThis.String(object.role) : "",
      isBlocked: isSet(object.isBlocked) ? globalThis.Boolean(object.isBlocked) : false,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
    };
  },

  toJSON(message: UserInfo): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.firstName !== "") {
      obj.firstName = message.firstName;
    }
    if (message.lastName !== "") {
      obj.lastName = message.lastName;
    }
    if (message.role !== "") {
      obj.role = message.role;
    }
    if (message.isBlocked !== false) {
      obj.isBlocked = message.isBlocked;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserInfo>, I>>(base?: I): UserInfo {
    return UserInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserInfo>, I>>(object: I): UserInfo {
    const message = createBaseUserInfo();
    message.userId = object.userId ?? "";
    message.username = object.username ?? "";
    message.email = object.email ?? "";
    message.firstName = object.firstName ?? "";
    message.lastName = object.lastName ?? "";
    message.role = object.role ?? "";
    message.isBlocked = object.isBlocked ?? false;
    message.createdAt = object.createdAt ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    return message;
  },
};

function createBasePaginationRequest(): PaginationRequest {
  return { page: 0, pageSize: 0 };
}

export const PaginationRequest: MessageFns<PaginationRequest> = {
  encode(message: PaginationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.page !== 0) {
      writer.uint32(8).int32(message.page);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaginationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaginationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaginationRequest {
    return {
      page: isSet(object.page) ? globalThis.Number(object.page) : 0,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
    };
  },

  toJSON(message: PaginationRequest): unknown {
    const obj: any = {};
    if (message.page !== 0) {
      obj.page = Math.round(message.page);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PaginationRequest>, I>>(base?: I): PaginationRequest {
    return PaginationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaginationRequest>, I>>(object: I): PaginationRequest {
    const message = createBasePaginationRequest();
    message.page = object.page ?? 0;
    message.pageSize = object.pageSize ?? 0;
    return message;
  },
};

function createBasePaginationResponse(): PaginationResponse {
  return { totalItems: 0, totalPages: 0 };
}

export const PaginationResponse: MessageFns<PaginationResponse> = {
  encode(message: PaginationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.totalItems !== 0) {
      writer.uint32(8).int32(message.totalItems);
    }
    if (message.totalPages !== 0) {
      writer.uint32(16).int32(message.totalPages);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaginationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaginationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.totalItems = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalPages = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaginationResponse {
    return {
      totalItems: isSet(object.totalItems) ? globalThis.Number(object.totalItems) : 0,
      totalPages: isSet(object.totalPages) ? globalThis.Number(object.totalPages) : 0,
    };
  },

  toJSON(message: PaginationResponse): unknown {
    const obj: any = {};
    if (message.totalItems !== 0) {
      obj.totalItems = Math.round(message.totalItems);
    }
    if (message.totalPages !== 0) {
      obj.totalPages = Math.round(message.totalPages);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PaginationResponse>, I>>(base?: I): PaginationResponse {
    return PaginationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaginationResponse>, I>>(object: I): PaginationResponse {
    const message = createBasePaginationResponse();
    message.totalItems = object.totalItems ?? 0;
    message.totalPages = object.totalPages ?? 0;
    return message;
  },
};

function createBaseError(): Error {
  return { code: "", message: "", details: [] };
}

export const Error: MessageFns<Error> = {
  encode(message: Error, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.details) {
      ErrorDetail.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Error {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.details.push(ErrorDetail.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Error {
    return {
      code: isSet(object.code) ? globalThis.String(object.code) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      details: globalThis.Array.isArray(object?.details) ? object.details.map((e: any) => ErrorDetail.fromJSON(e)) : [],
    };
  },

  toJSON(message: Error): unknown {
    const obj: any = {};
    if (message.code !== "") {
      obj.code = message.code;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.details?.length) {
      obj.details = message.details.map((e) => ErrorDetail.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Error>, I>>(base?: I): Error {
    return Error.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Error>, I>>(object: I): Error {
    const message = createBaseError();
    message.code = object.code ?? "";
    message.message = object.message ?? "";
    message.details = object.details?.map((e) => ErrorDetail.fromPartial(e)) || [];
    return message;
  },
};

function createBaseErrorDetail(): ErrorDetail {
  return { field: "", message: "" };
}

export const ErrorDetail: MessageFns<ErrorDetail> = {
  encode(message: ErrorDetail, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.field !== "") {
      writer.uint32(10).string(message.field);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ErrorDetail {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseErrorDetail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.field = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ErrorDetail {
    return {
      field: isSet(object.field) ? globalThis.String(object.field) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: ErrorDetail): unknown {
    const obj: any = {};
    if (message.field !== "") {
      obj.field = message.field;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ErrorDetail>, I>>(base?: I): ErrorDetail {
    return ErrorDetail.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ErrorDetail>, I>>(object: I): ErrorDetail {
    const message = createBaseErrorDetail();
    message.field = object.field ?? "";
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseWalletTransaction(): WalletTransaction {
  return { transactionId: "", userId: "", amount: 0, type: "", transactionDate: undefined };
}

export const WalletTransaction: MessageFns<WalletTransaction> = {
  encode(message: WalletTransaction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transactionId !== "") {
      writer.uint32(10).string(message.transactionId);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.amount !== 0) {
      writer.uint32(25).double(message.amount);
    }
    if (message.type !== "") {
      writer.uint32(34).string(message.type);
    }
    if (message.transactionDate !== undefined) {
      Timestamp.encode(toTimestamp(message.transactionDate), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WalletTransaction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWalletTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transactionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.amount = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.transactionDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WalletTransaction {
    return {
      transactionId: isSet(object.transactionId) ? globalThis.String(object.transactionId) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      transactionDate: isSet(object.transactionDate) ? fromJsonTimestamp(object.transactionDate) : undefined,
    };
  },

  toJSON(message: WalletTransaction): unknown {
    const obj: any = {};
    if (message.transactionId !== "") {
      obj.transactionId = message.transactionId;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.amount !== 0) {
      obj.amount = message.amount;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.transactionDate !== undefined) {
      obj.transactionDate = message.transactionDate.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WalletTransaction>, I>>(base?: I): WalletTransaction {
    return WalletTransaction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WalletTransaction>, I>>(object: I): WalletTransaction {
    const message = createBaseWalletTransaction();
    message.transactionId = object.transactionId ?? "";
    message.userId = object.userId ?? "";
    message.amount = object.amount ?? 0;
    message.type = object.type ?? "";
    message.transactionDate = object.transactionDate ?? undefined;
    return message;
  },
};

function createBaseRegisterUserRequest(): RegisterUserRequest {
  return { username: "", email: "", password: "", role: "", avatar: "", authType: "" };
}

export const RegisterUserRequest: MessageFns<RegisterUserRequest> = {
  encode(message: RegisterUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    if (message.email !== "") {
      writer.uint32(18).string(message.email);
    }
    if (message.password !== "") {
      writer.uint32(26).string(message.password);
    }
    if (message.role !== "") {
      writer.uint32(34).string(message.role);
    }
    if (message.avatar !== "") {
      writer.uint32(42).string(message.avatar);
    }
    if (message.authType !== "") {
      writer.uint32(50).string(message.authType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegisterUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.password = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.role = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.avatar = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.authType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterUserRequest {
    return {
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
      role: isSet(object.role) ? globalThis.String(object.role) : "",
      avatar: isSet(object.avatar) ? globalThis.String(object.avatar) : "",
      authType: isSet(object.authType) ? globalThis.String(object.authType) : "",
    };
  },

  toJSON(message: RegisterUserRequest): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    if (message.role !== "") {
      obj.role = message.role;
    }
    if (message.avatar !== "") {
      obj.avatar = message.avatar;
    }
    if (message.authType !== "") {
      obj.authType = message.authType;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegisterUserRequest>, I>>(base?: I): RegisterUserRequest {
    return RegisterUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegisterUserRequest>, I>>(object: I): RegisterUserRequest {
    const message = createBaseRegisterUserRequest();
    message.username = object.username ?? "";
    message.email = object.email ?? "";
    message.password = object.password ?? "";
    message.role = object.role ?? "";
    message.avatar = object.avatar ?? "";
    message.authType = object.authType ?? "";
    return message;
  },
};

function createBaseVerifyUserRequest(): VerifyUserRequest {
  return { email: "" };
}

export const VerifyUserRequest: MessageFns<VerifyUserRequest> = {
  encode(message: VerifyUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VerifyUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerifyUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VerifyUserRequest {
    return { email: isSet(object.email) ? globalThis.String(object.email) : "" };
  },

  toJSON(message: VerifyUserRequest): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VerifyUserRequest>, I>>(base?: I): VerifyUserRequest {
    return VerifyUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VerifyUserRequest>, I>>(object: I): VerifyUserRequest {
    const message = createBaseVerifyUserRequest();
    message.email = object.email ?? "";
    return message;
  },
};

function createBaseRegisterUserResponse(): RegisterUserResponse {
  return { userId: undefined, error: undefined };
}

export const RegisterUserResponse: MessageFns<RegisterUserResponse> = {
  encode(message: RegisterUserResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== undefined) {
      writer.uint32(10).string(message.userId);
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegisterUserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterUserResponse {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: RegisterUserResponse): unknown {
    const obj: any = {};
    if (message.userId !== undefined) {
      obj.userId = message.userId;
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegisterUserResponse>, I>>(base?: I): RegisterUserResponse {
    return RegisterUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegisterUserResponse>, I>>(object: I): RegisterUserResponse {
    const message = createBaseRegisterUserResponse();
    message.userId = object.userId ?? undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    return message;
  },
};

function createBaseLoginUserRequest(): LoginUserRequest {
  return { email: "", password: "", authType: "" };
}

export const LoginUserRequest: MessageFns<LoginUserRequest> = {
  encode(message: LoginUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    if (message.password !== "") {
      writer.uint32(18).string(message.password);
    }
    if (message.authType !== "") {
      writer.uint32(50).string(message.authType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoginUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoginUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.authType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoginUserRequest {
    return {
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
      authType: isSet(object.authType) ? globalThis.String(object.authType) : "",
    };
  },

  toJSON(message: LoginUserRequest): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    if (message.authType !== "") {
      obj.authType = message.authType;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoginUserRequest>, I>>(base?: I): LoginUserRequest {
    return LoginUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoginUserRequest>, I>>(object: I): LoginUserRequest {
    const message = createBaseLoginUserRequest();
    message.email = object.email ?? "";
    message.password = object.password ?? "";
    message.authType = object.authType ?? "";
    return message;
  },
};

function createBaseLoginUserResponse(): LoginUserResponse {
  return { success: undefined, error: undefined };
}

export const LoginUserResponse: MessageFns<LoginUserResponse> = {
  encode(message: LoginUserResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== undefined) {
      LoginSuccess.encode(message.success, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoginUserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoginUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.success = LoginSuccess.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoginUserResponse {
    return {
      success: isSet(object.success) ? LoginSuccess.fromJSON(object.success) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: LoginUserResponse): unknown {
    const obj: any = {};
    if (message.success !== undefined) {
      obj.success = LoginSuccess.toJSON(message.success);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoginUserResponse>, I>>(base?: I): LoginUserResponse {
    return LoginUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoginUserResponse>, I>>(object: I): LoginUserResponse {
    const message = createBaseLoginUserResponse();
    message.success = (object.success !== undefined && object.success !== null)
      ? LoginSuccess.fromPartial(object.success)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    return message;
  },
};

function createBaseVerifyUserResponse(): VerifyUserResponse {
  return { success: undefined, error: undefined };
}

export const VerifyUserResponse: MessageFns<VerifyUserResponse> = {
  encode(message: VerifyUserResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== undefined) {
      VerifySuccess.encode(message.success, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VerifyUserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerifyUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.success = VerifySuccess.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VerifyUserResponse {
    return {
      success: isSet(object.success) ? VerifySuccess.fromJSON(object.success) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: VerifyUserResponse): unknown {
    const obj: any = {};
    if (message.success !== undefined) {
      obj.success = VerifySuccess.toJSON(message.success);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VerifyUserResponse>, I>>(base?: I): VerifyUserResponse {
    return VerifyUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VerifyUserResponse>, I>>(object: I): VerifyUserResponse {
    const message = createBaseVerifyUserResponse();
    message.success = (object.success !== undefined && object.success !== null)
      ? VerifySuccess.fromPartial(object.success)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    return message;
  },
};

function createBaseLoginSuccess(): LoginSuccess {
  return { accessToken: "", refreshToken: "", user: undefined };
}

export const LoginSuccess: MessageFns<LoginSuccess> = {
  encode(message: LoginSuccess, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessToken !== "") {
      writer.uint32(10).string(message.accessToken);
    }
    if (message.refreshToken !== "") {
      writer.uint32(18).string(message.refreshToken);
    }
    if (message.user !== undefined) {
      UserInfo.encode(message.user, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoginSuccess {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoginSuccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.user = UserInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoginSuccess {
    return {
      accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "",
      refreshToken: isSet(object.refreshToken) ? globalThis.String(object.refreshToken) : "",
      user: isSet(object.user) ? UserInfo.fromJSON(object.user) : undefined,
    };
  },

  toJSON(message: LoginSuccess): unknown {
    const obj: any = {};
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    if (message.refreshToken !== "") {
      obj.refreshToken = message.refreshToken;
    }
    if (message.user !== undefined) {
      obj.user = UserInfo.toJSON(message.user);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoginSuccess>, I>>(base?: I): LoginSuccess {
    return LoginSuccess.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoginSuccess>, I>>(object: I): LoginSuccess {
    const message = createBaseLoginSuccess();
    message.accessToken = object.accessToken ?? "";
    message.refreshToken = object.refreshToken ?? "";
    message.user = (object.user !== undefined && object.user !== null) ? UserInfo.fromPartial(object.user) : undefined;
    return message;
  },
};

function createBaseVerifySuccess(): VerifySuccess {
  return { accessToken: "", refreshToken: "", user: undefined };
}

export const VerifySuccess: MessageFns<VerifySuccess> = {
  encode(message: VerifySuccess, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessToken !== "") {
      writer.uint32(10).string(message.accessToken);
    }
    if (message.refreshToken !== "") {
      writer.uint32(18).string(message.refreshToken);
    }
    if (message.user !== undefined) {
      UserInfo.encode(message.user, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VerifySuccess {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerifySuccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.user = UserInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VerifySuccess {
    return {
      accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "",
      refreshToken: isSet(object.refreshToken) ? globalThis.String(object.refreshToken) : "",
      user: isSet(object.user) ? UserInfo.fromJSON(object.user) : undefined,
    };
  },

  toJSON(message: VerifySuccess): unknown {
    const obj: any = {};
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    if (message.refreshToken !== "") {
      obj.refreshToken = message.refreshToken;
    }
    if (message.user !== undefined) {
      obj.user = UserInfo.toJSON(message.user);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VerifySuccess>, I>>(base?: I): VerifySuccess {
    return VerifySuccess.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VerifySuccess>, I>>(object: I): VerifySuccess {
    const message = createBaseVerifySuccess();
    message.accessToken = object.accessToken ?? "";
    message.refreshToken = object.refreshToken ?? "";
    message.user = (object.user !== undefined && object.user !== null) ? UserInfo.fromPartial(object.user) : undefined;
    return message;
  },
};

function createBaseGetNewRefreshTokenRequest(): GetNewRefreshTokenRequest {
  return { refreshToken: "" };
}

export const GetNewRefreshTokenRequest: MessageFns<GetNewRefreshTokenRequest> = {
  encode(message: GetNewRefreshTokenRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.refreshToken !== "") {
      writer.uint32(10).string(message.refreshToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNewRefreshTokenRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNewRefreshTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNewRefreshTokenRequest {
    return { refreshToken: isSet(object.refreshToken) ? globalThis.String(object.refreshToken) : "" };
  },

  toJSON(message: GetNewRefreshTokenRequest): unknown {
    const obj: any = {};
    if (message.refreshToken !== "") {
      obj.refreshToken = message.refreshToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetNewRefreshTokenRequest>, I>>(base?: I): GetNewRefreshTokenRequest {
    return GetNewRefreshTokenRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetNewRefreshTokenRequest>, I>>(object: I): GetNewRefreshTokenRequest {
    const message = createBaseGetNewRefreshTokenRequest();
    message.refreshToken = object.refreshToken ?? "";
    return message;
  },
};

function createBaseGetNewRefreshTokenResponse(): GetNewRefreshTokenResponse {
  return { success: undefined, error: undefined };
}

export const GetNewRefreshTokenResponse: MessageFns<GetNewRefreshTokenResponse> = {
  encode(message: GetNewRefreshTokenResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== undefined) {
      RefreshSuccess.encode(message.success, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNewRefreshTokenResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNewRefreshTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.success = RefreshSuccess.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNewRefreshTokenResponse {
    return {
      success: isSet(object.success) ? RefreshSuccess.fromJSON(object.success) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: GetNewRefreshTokenResponse): unknown {
    const obj: any = {};
    if (message.success !== undefined) {
      obj.success = RefreshSuccess.toJSON(message.success);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetNewRefreshTokenResponse>, I>>(base?: I): GetNewRefreshTokenResponse {
    return GetNewRefreshTokenResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetNewRefreshTokenResponse>, I>>(object: I): GetNewRefreshTokenResponse {
    const message = createBaseGetNewRefreshTokenResponse();
    message.success = (object.success !== undefined && object.success !== null)
      ? RefreshSuccess.fromPartial(object.success)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    return message;
  },
};

function createBaseRefreshSuccess(): RefreshSuccess {
  return { accessToken: "", refreshToken: "" };
}

export const RefreshSuccess: MessageFns<RefreshSuccess> = {
  encode(message: RefreshSuccess, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessToken !== "") {
      writer.uint32(10).string(message.accessToken);
    }
    if (message.refreshToken !== "") {
      writer.uint32(18).string(message.refreshToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RefreshSuccess {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefreshSuccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RefreshSuccess {
    return {
      accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "",
      refreshToken: isSet(object.refreshToken) ? globalThis.String(object.refreshToken) : "",
    };
  },

  toJSON(message: RefreshSuccess): unknown {
    const obj: any = {};
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    if (message.refreshToken !== "") {
      obj.refreshToken = message.refreshToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RefreshSuccess>, I>>(base?: I): RefreshSuccess {
    return RefreshSuccess.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RefreshSuccess>, I>>(object: I): RefreshSuccess {
    const message = createBaseRefreshSuccess();
    message.accessToken = object.accessToken ?? "";
    message.refreshToken = object.refreshToken ?? "";
    return message;
  },
};

function createBaseForgotPasswordRequest(): ForgotPasswordRequest {
  return { email: "" };
}

export const ForgotPasswordRequest: MessageFns<ForgotPasswordRequest> = {
  encode(message: ForgotPasswordRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ForgotPasswordRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseForgotPasswordRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ForgotPasswordRequest {
    return { email: isSet(object.email) ? globalThis.String(object.email) : "" };
  },

  toJSON(message: ForgotPasswordRequest): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ForgotPasswordRequest>, I>>(base?: I): ForgotPasswordRequest {
    return ForgotPasswordRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ForgotPasswordRequest>, I>>(object: I): ForgotPasswordRequest {
    const message = createBaseForgotPasswordRequest();
    message.email = object.email ?? "";
    return message;
  },
};

function createBaseForgotPasswordResponse(): ForgotPasswordResponse {
  return { success: undefined, error: undefined };
}

export const ForgotPasswordResponse: MessageFns<ForgotPasswordResponse> = {
  encode(message: ForgotPasswordResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== undefined) {
      ForgotPasswordSuccess.encode(message.success, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ForgotPasswordResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseForgotPasswordResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.success = ForgotPasswordSuccess.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ForgotPasswordResponse {
    return {
      success: isSet(object.success) ? ForgotPasswordSuccess.fromJSON(object.success) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: ForgotPasswordResponse): unknown {
    const obj: any = {};
    if (message.success !== undefined) {
      obj.success = ForgotPasswordSuccess.toJSON(message.success);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ForgotPasswordResponse>, I>>(base?: I): ForgotPasswordResponse {
    return ForgotPasswordResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ForgotPasswordResponse>, I>>(object: I): ForgotPasswordResponse {
    const message = createBaseForgotPasswordResponse();
    message.success = (object.success !== undefined && object.success !== null)
      ? ForgotPasswordSuccess.fromPartial(object.success)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    return message;
  },
};

function createBaseForgotPasswordSuccess(): ForgotPasswordSuccess {
  return { acknowledged: false };
}

export const ForgotPasswordSuccess: MessageFns<ForgotPasswordSuccess> = {
  encode(message: ForgotPasswordSuccess, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.acknowledged !== false) {
      writer.uint32(8).bool(message.acknowledged);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ForgotPasswordSuccess {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseForgotPasswordSuccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.acknowledged = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ForgotPasswordSuccess {
    return { acknowledged: isSet(object.acknowledged) ? globalThis.Boolean(object.acknowledged) : false };
  },

  toJSON(message: ForgotPasswordSuccess): unknown {
    const obj: any = {};
    if (message.acknowledged !== false) {
      obj.acknowledged = message.acknowledged;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ForgotPasswordSuccess>, I>>(base?: I): ForgotPasswordSuccess {
    return ForgotPasswordSuccess.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ForgotPasswordSuccess>, I>>(object: I): ForgotPasswordSuccess {
    const message = createBaseForgotPasswordSuccess();
    message.acknowledged = object.acknowledged ?? false;
    return message;
  },
};

function createBaseUpdateUserDetailsRequest(): UpdateUserDetailsRequest {
  return { userId: "", firstName: "", lastName: "" };
}

export const UpdateUserDetailsRequest: MessageFns<UpdateUserDetailsRequest> = {
  encode(message: UpdateUserDetailsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.firstName !== "") {
      writer.uint32(18).string(message.firstName);
    }
    if (message.lastName !== "") {
      writer.uint32(26).string(message.lastName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateUserDetailsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateUserDetailsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.firstName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.lastName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateUserDetailsRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      firstName: isSet(object.firstName) ? globalThis.String(object.firstName) : "",
      lastName: isSet(object.lastName) ? globalThis.String(object.lastName) : "",
    };
  },

  toJSON(message: UpdateUserDetailsRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.firstName !== "") {
      obj.firstName = message.firstName;
    }
    if (message.lastName !== "") {
      obj.lastName = message.lastName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateUserDetailsRequest>, I>>(base?: I): UpdateUserDetailsRequest {
    return UpdateUserDetailsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateUserDetailsRequest>, I>>(object: I): UpdateUserDetailsRequest {
    const message = createBaseUpdateUserDetailsRequest();
    message.userId = object.userId ?? "";
    message.firstName = object.firstName ?? "";
    message.lastName = object.lastName ?? "";
    return message;
  },
};

function createBaseUpdateUserDetailsResponse(): UpdateUserDetailsResponse {
  return { user: undefined, error: undefined };
}

export const UpdateUserDetailsResponse: MessageFns<UpdateUserDetailsResponse> = {
  encode(message: UpdateUserDetailsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user !== undefined) {
      UserInfo.encode(message.user, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateUserDetailsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateUserDetailsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = UserInfo.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateUserDetailsResponse {
    return {
      user: isSet(object.user) ? UserInfo.fromJSON(object.user) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: UpdateUserDetailsResponse): unknown {
    const obj: any = {};
    if (message.user !== undefined) {
      obj.user = UserInfo.toJSON(message.user);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateUserDetailsResponse>, I>>(base?: I): UpdateUserDetailsResponse {
    return UpdateUserDetailsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateUserDetailsResponse>, I>>(object: I): UpdateUserDetailsResponse {
    const message = createBaseUpdateUserDetailsResponse();
    message.user = (object.user !== undefined && object.user !== null) ? UserInfo.fromPartial(object.user) : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    return message;
  },
};

function createBaseChangePasswordRequest(): ChangePasswordRequest {
  return { userId: "", oldPassword: "", newPassword: "" };
}

export const ChangePasswordRequest: MessageFns<ChangePasswordRequest> = {
  encode(message: ChangePasswordRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.oldPassword !== "") {
      writer.uint32(18).string(message.oldPassword);
    }
    if (message.newPassword !== "") {
      writer.uint32(26).string(message.newPassword);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChangePasswordRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangePasswordRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.oldPassword = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.newPassword = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChangePasswordRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      oldPassword: isSet(object.oldPassword) ? globalThis.String(object.oldPassword) : "",
      newPassword: isSet(object.newPassword) ? globalThis.String(object.newPassword) : "",
    };
  },

  toJSON(message: ChangePasswordRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.oldPassword !== "") {
      obj.oldPassword = message.oldPassword;
    }
    if (message.newPassword !== "") {
      obj.newPassword = message.newPassword;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChangePasswordRequest>, I>>(base?: I): ChangePasswordRequest {
    return ChangePasswordRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChangePasswordRequest>, I>>(object: I): ChangePasswordRequest {
    const message = createBaseChangePasswordRequest();
    message.userId = object.userId ?? "";
    message.oldPassword = object.oldPassword ?? "";
    message.newPassword = object.newPassword ?? "";
    return message;
  },
};

function createBaseChangePasswordResponse(): ChangePasswordResponse {
  return { success: undefined, error: undefined };
}

export const ChangePasswordResponse: MessageFns<ChangePasswordResponse> = {
  encode(message: ChangePasswordResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== undefined) {
      ChangePasswordSuccess.encode(message.success, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChangePasswordResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangePasswordResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.success = ChangePasswordSuccess.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChangePasswordResponse {
    return {
      success: isSet(object.success) ? ChangePasswordSuccess.fromJSON(object.success) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: ChangePasswordResponse): unknown {
    const obj: any = {};
    if (message.success !== undefined) {
      obj.success = ChangePasswordSuccess.toJSON(message.success);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChangePasswordResponse>, I>>(base?: I): ChangePasswordResponse {
    return ChangePasswordResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChangePasswordResponse>, I>>(object: I): ChangePasswordResponse {
    const message = createBaseChangePasswordResponse();
    message.success = (object.success !== undefined && object.success !== null)
      ? ChangePasswordSuccess.fromPartial(object.success)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    return message;
  },
};

function createBaseChangePasswordSuccess(): ChangePasswordSuccess {
  return { updated: false };
}

export const ChangePasswordSuccess: MessageFns<ChangePasswordSuccess> = {
  encode(message: ChangePasswordSuccess, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updated !== false) {
      writer.uint32(8).bool(message.updated);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChangePasswordSuccess {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangePasswordSuccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.updated = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChangePasswordSuccess {
    return { updated: isSet(object.updated) ? globalThis.Boolean(object.updated) : false };
  },

  toJSON(message: ChangePasswordSuccess): unknown {
    const obj: any = {};
    if (message.updated !== false) {
      obj.updated = message.updated;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChangePasswordSuccess>, I>>(base?: I): ChangePasswordSuccess {
    return ChangePasswordSuccess.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChangePasswordSuccess>, I>>(object: I): ChangePasswordSuccess {
    const message = createBaseChangePasswordSuccess();
    message.updated = object.updated ?? false;
    return message;
  },
};

function createBaseGetWalletTransactionsRequest(): GetWalletTransactionsRequest {
  return { userId: "", pagination: undefined };
}

export const GetWalletTransactionsRequest: MessageFns<GetWalletTransactionsRequest> = {
  encode(message: GetWalletTransactionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.pagination !== undefined) {
      PaginationRequest.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetWalletTransactionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWalletTransactionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWalletTransactionsRequest {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      pagination: isSet(object.pagination) ? PaginationRequest.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: GetWalletTransactionsRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.pagination !== undefined) {
      obj.pagination = PaginationRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetWalletTransactionsRequest>, I>>(base?: I): GetWalletTransactionsRequest {
    return GetWalletTransactionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetWalletTransactionsRequest>, I>>(object: I): GetWalletTransactionsRequest {
    const message = createBaseGetWalletTransactionsRequest();
    message.userId = object.userId ?? "";
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PaginationRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseGetWalletTransactionsResponse(): GetWalletTransactionsResponse {
  return { success: undefined, error: undefined };
}

export const GetWalletTransactionsResponse: MessageFns<GetWalletTransactionsResponse> = {
  encode(message: GetWalletTransactionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== undefined) {
      WalletTransactionsSuccess.encode(message.success, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetWalletTransactionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWalletTransactionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.success = WalletTransactionsSuccess.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWalletTransactionsResponse {
    return {
      success: isSet(object.success) ? WalletTransactionsSuccess.fromJSON(object.success) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: GetWalletTransactionsResponse): unknown {
    const obj: any = {};
    if (message.success !== undefined) {
      obj.success = WalletTransactionsSuccess.toJSON(message.success);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetWalletTransactionsResponse>, I>>(base?: I): GetWalletTransactionsResponse {
    return GetWalletTransactionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetWalletTransactionsResponse>, I>>(
    object: I,
  ): GetWalletTransactionsResponse {
    const message = createBaseGetWalletTransactionsResponse();
    message.success = (object.success !== undefined && object.success !== null)
      ? WalletTransactionsSuccess.fromPartial(object.success)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    return message;
  },
};

function createBaseWalletTransactionsSuccess(): WalletTransactionsSuccess {
  return { transactions: [], pagination: undefined };
}

export const WalletTransactionsSuccess: MessageFns<WalletTransactionsSuccess> = {
  encode(message: WalletTransactionsSuccess, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.transactions) {
      WalletTransaction.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WalletTransactionsSuccess {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWalletTransactionsSuccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transactions.push(WalletTransaction.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WalletTransactionsSuccess {
    return {
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => WalletTransaction.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PaginationResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: WalletTransactionsSuccess): unknown {
    const obj: any = {};
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) => WalletTransaction.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PaginationResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WalletTransactionsSuccess>, I>>(base?: I): WalletTransactionsSuccess {
    return WalletTransactionsSuccess.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WalletTransactionsSuccess>, I>>(object: I): WalletTransactionsSuccess {
    const message = createBaseWalletTransactionsSuccess();
    message.transactions = object.transactions?.map((e) => WalletTransaction.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PaginationResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseGetAllUsersRequest(): GetAllUsersRequest {
  return { pagination: undefined };
}

export const GetAllUsersRequest: MessageFns<GetAllUsersRequest> = {
  encode(message: GetAllUsersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pagination !== undefined) {
      PaginationRequest.encode(message.pagination, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAllUsersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllUsersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pagination = PaginationRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAllUsersRequest {
    return { pagination: isSet(object.pagination) ? PaginationRequest.fromJSON(object.pagination) : undefined };
  },

  toJSON(message: GetAllUsersRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PaginationRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAllUsersRequest>, I>>(base?: I): GetAllUsersRequest {
    return GetAllUsersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAllUsersRequest>, I>>(object: I): GetAllUsersRequest {
    const message = createBaseGetAllUsersRequest();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PaginationRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseGetAllUserEmailsRequest(): GetAllUserEmailsRequest {
  return { pagination: undefined };
}

export const GetAllUserEmailsRequest: MessageFns<GetAllUserEmailsRequest> = {
  encode(message: GetAllUserEmailsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pagination !== undefined) {
      PaginationRequest.encode(message.pagination, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAllUserEmailsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllUserEmailsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pagination = PaginationRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAllUserEmailsRequest {
    return { pagination: isSet(object.pagination) ? PaginationRequest.fromJSON(object.pagination) : undefined };
  },

  toJSON(message: GetAllUserEmailsRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PaginationRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAllUserEmailsRequest>, I>>(base?: I): GetAllUserEmailsRequest {
    return GetAllUserEmailsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAllUserEmailsRequest>, I>>(object: I): GetAllUserEmailsRequest {
    const message = createBaseGetAllUserEmailsRequest();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PaginationRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseGetAllUsersResponse(): GetAllUsersResponse {
  return { success: undefined, error: undefined };
}

export const GetAllUsersResponse: MessageFns<GetAllUsersResponse> = {
  encode(message: GetAllUsersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== undefined) {
      AllUsersSuccess.encode(message.success, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAllUsersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllUsersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.success = AllUsersSuccess.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAllUsersResponse {
    return {
      success: isSet(object.success) ? AllUsersSuccess.fromJSON(object.success) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: GetAllUsersResponse): unknown {
    const obj: any = {};
    if (message.success !== undefined) {
      obj.success = AllUsersSuccess.toJSON(message.success);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAllUsersResponse>, I>>(base?: I): GetAllUsersResponse {
    return GetAllUsersResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAllUsersResponse>, I>>(object: I): GetAllUsersResponse {
    const message = createBaseGetAllUsersResponse();
    message.success = (object.success !== undefined && object.success !== null)
      ? AllUsersSuccess.fromPartial(object.success)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    return message;
  },
};

function createBaseGetAllUserEmailsResponse(): GetAllUserEmailsResponse {
  return { success: undefined, error: undefined };
}

export const GetAllUserEmailsResponse: MessageFns<GetAllUserEmailsResponse> = {
  encode(message: GetAllUserEmailsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== undefined) {
      AllUserEmailsSuccess.encode(message.success, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAllUserEmailsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllUserEmailsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.success = AllUserEmailsSuccess.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAllUserEmailsResponse {
    return {
      success: isSet(object.success) ? AllUserEmailsSuccess.fromJSON(object.success) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: GetAllUserEmailsResponse): unknown {
    const obj: any = {};
    if (message.success !== undefined) {
      obj.success = AllUserEmailsSuccess.toJSON(message.success);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAllUserEmailsResponse>, I>>(base?: I): GetAllUserEmailsResponse {
    return GetAllUserEmailsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAllUserEmailsResponse>, I>>(object: I): GetAllUserEmailsResponse {
    const message = createBaseGetAllUserEmailsResponse();
    message.success = (object.success !== undefined && object.success !== null)
      ? AllUserEmailsSuccess.fromPartial(object.success)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    return message;
  },
};

function createBaseAllUserEmailsSuccess(): AllUserEmailsSuccess {
  return { email: [] };
}

export const AllUserEmailsSuccess: MessageFns<AllUserEmailsSuccess> = {
  encode(message: AllUserEmailsSuccess, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.email) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AllUserEmailsSuccess {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAllUserEmailsSuccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AllUserEmailsSuccess {
    return { email: globalThis.Array.isArray(object?.email) ? object.email.map((e: any) => globalThis.String(e)) : [] };
  },

  toJSON(message: AllUserEmailsSuccess): unknown {
    const obj: any = {};
    if (message.email?.length) {
      obj.email = message.email;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AllUserEmailsSuccess>, I>>(base?: I): AllUserEmailsSuccess {
    return AllUserEmailsSuccess.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AllUserEmailsSuccess>, I>>(object: I): AllUserEmailsSuccess {
    const message = createBaseAllUserEmailsSuccess();
    message.email = object.email?.map((e) => e) || [];
    return message;
  },
};

function createBaseAllUsersSuccess(): AllUsersSuccess {
  return { users: [], pagination: undefined };
}

export const AllUsersSuccess: MessageFns<AllUsersSuccess> = {
  encode(message: AllUsersSuccess, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.users) {
      UserInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AllUsersSuccess {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAllUsersSuccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.users.push(UserInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AllUsersSuccess {
    return {
      users: globalThis.Array.isArray(object?.users) ? object.users.map((e: any) => UserInfo.fromJSON(e)) : [],
      pagination: isSet(object.pagination) ? PaginationResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: AllUsersSuccess): unknown {
    const obj: any = {};
    if (message.users?.length) {
      obj.users = message.users.map((e) => UserInfo.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PaginationResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AllUsersSuccess>, I>>(base?: I): AllUsersSuccess {
    return AllUsersSuccess.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AllUsersSuccess>, I>>(object: I): AllUsersSuccess {
    const message = createBaseAllUsersSuccess();
    message.users = object.users?.map((e) => UserInfo.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PaginationResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseGetUserByIdRequest(): GetUserByIdRequest {
  return { userId: "" };
}

export const GetUserByIdRequest: MessageFns<GetUserByIdRequest> = {
  encode(message: GetUserByIdRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserByIdRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserByIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserByIdRequest {
    return { userId: isSet(object.userId) ? globalThis.String(object.userId) : "" };
  },

  toJSON(message: GetUserByIdRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserByIdRequest>, I>>(base?: I): GetUserByIdRequest {
    return GetUserByIdRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUserByIdRequest>, I>>(object: I): GetUserByIdRequest {
    const message = createBaseGetUserByIdRequest();
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseCheckUserByEmailRequest(): CheckUserByEmailRequest {
  return { email: "" };
}

export const CheckUserByEmailRequest: MessageFns<CheckUserByEmailRequest> = {
  encode(message: CheckUserByEmailRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckUserByEmailRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckUserByEmailRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckUserByEmailRequest {
    return { email: isSet(object.email) ? globalThis.String(object.email) : "" };
  },

  toJSON(message: CheckUserByEmailRequest): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CheckUserByEmailRequest>, I>>(base?: I): CheckUserByEmailRequest {
    return CheckUserByEmailRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CheckUserByEmailRequest>, I>>(object: I): CheckUserByEmailRequest {
    const message = createBaseCheckUserByEmailRequest();
    message.email = object.email ?? "";
    return message;
  },
};

function createBaseEmailExist(): EmailExist {
  return { success: "", error: "" };
}

export const EmailExist: MessageFns<EmailExist> = {
  encode(message: EmailExist, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== "") {
      writer.uint32(10).string(message.success);
    }
    if (message.error !== "") {
      writer.uint32(18).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmailExist {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmailExist();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.success = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EmailExist {
    return {
      success: isSet(object.success) ? globalThis.String(object.success) : "",
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: EmailExist): unknown {
    const obj: any = {};
    if (message.success !== "") {
      obj.success = message.success;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EmailExist>, I>>(base?: I): EmailExist {
    return EmailExist.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EmailExist>, I>>(object: I): EmailExist {
    const message = createBaseEmailExist();
    message.success = object.success ?? "";
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseCheckUserByEmailResponse(): CheckUserByEmailResponse {
  return { response: undefined, error: undefined };
}

export const CheckUserByEmailResponse: MessageFns<CheckUserByEmailResponse> = {
  encode(message: CheckUserByEmailResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.response !== undefined) {
      EmailExist.encode(message.response, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckUserByEmailResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckUserByEmailResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.response = EmailExist.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckUserByEmailResponse {
    return {
      response: isSet(object.response) ? EmailExist.fromJSON(object.response) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: CheckUserByEmailResponse): unknown {
    const obj: any = {};
    if (message.response !== undefined) {
      obj.response = EmailExist.toJSON(message.response);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CheckUserByEmailResponse>, I>>(base?: I): CheckUserByEmailResponse {
    return CheckUserByEmailResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CheckUserByEmailResponse>, I>>(object: I): CheckUserByEmailResponse {
    const message = createBaseCheckUserByEmailResponse();
    message.response = (object.response !== undefined && object.response !== null)
      ? EmailExist.fromPartial(object.response)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    return message;
  },
};

function createBaseGetUserByIdResponse(): GetUserByIdResponse {
  return { user: undefined, error: undefined };
}

export const GetUserByIdResponse: MessageFns<GetUserByIdResponse> = {
  encode(message: GetUserByIdResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user !== undefined) {
      UserInfo.encode(message.user, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserByIdResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserByIdResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = UserInfo.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserByIdResponse {
    return {
      user: isSet(object.user) ? UserInfo.fromJSON(object.user) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: GetUserByIdResponse): unknown {
    const obj: any = {};
    if (message.user !== undefined) {
      obj.user = UserInfo.toJSON(message.user);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserByIdResponse>, I>>(base?: I): GetUserByIdResponse {
    return GetUserByIdResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUserByIdResponse>, I>>(object: I): GetUserByIdResponse {
    const message = createBaseGetUserByIdResponse();
    message.user = (object.user !== undefined && object.user !== null) ? UserInfo.fromPartial(object.user) : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    return message;
  },
};

function createBaseBlockUserRequest(): BlockUserRequest {
  return { userId: "" };
}

export const BlockUserRequest: MessageFns<BlockUserRequest> = {
  encode(message: BlockUserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockUserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockUserRequest {
    return { userId: isSet(object.userId) ? globalThis.String(object.userId) : "" };
  },

  toJSON(message: BlockUserRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockUserRequest>, I>>(base?: I): BlockUserRequest {
    return BlockUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockUserRequest>, I>>(object: I): BlockUserRequest {
    const message = createBaseBlockUserRequest();
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseBlockUserResponse(): BlockUserResponse {
  return { success: undefined, error: undefined };
}

export const BlockUserResponse: MessageFns<BlockUserResponse> = {
  encode(message: BlockUserResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== undefined) {
      BlockUserSuccess.encode(message.success, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockUserResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.success = BlockUserSuccess.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockUserResponse {
    return {
      success: isSet(object.success) ? BlockUserSuccess.fromJSON(object.success) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: BlockUserResponse): unknown {
    const obj: any = {};
    if (message.success !== undefined) {
      obj.success = BlockUserSuccess.toJSON(message.success);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockUserResponse>, I>>(base?: I): BlockUserResponse {
    return BlockUserResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockUserResponse>, I>>(object: I): BlockUserResponse {
    const message = createBaseBlockUserResponse();
    message.success = (object.success !== undefined && object.success !== null)
      ? BlockUserSuccess.fromPartial(object.success)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    return message;
  },
};

function createBaseBlockUserSuccess(): BlockUserSuccess {
  return { updated: false };
}

export const BlockUserSuccess: MessageFns<BlockUserSuccess> = {
  encode(message: BlockUserSuccess, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updated !== false) {
      writer.uint32(8).bool(message.updated);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockUserSuccess {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockUserSuccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.updated = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockUserSuccess {
    return { updated: isSet(object.updated) ? globalThis.Boolean(object.updated) : false };
  },

  toJSON(message: BlockUserSuccess): unknown {
    const obj: any = {};
    if (message.updated !== false) {
      obj.updated = message.updated;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockUserSuccess>, I>>(base?: I): BlockUserSuccess {
    return BlockUserSuccess.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockUserSuccess>, I>>(object: I): BlockUserSuccess {
    const message = createBaseBlockUserSuccess();
    message.updated = object.updated ?? false;
    return message;
  },
};

function createBaseGetAllInstructorsRequest(): GetAllInstructorsRequest {
  return { pagination: undefined };
}

export const GetAllInstructorsRequest: MessageFns<GetAllInstructorsRequest> = {
  encode(message: GetAllInstructorsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pagination !== undefined) {
      PaginationRequest.encode(message.pagination, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAllInstructorsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllInstructorsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pagination = PaginationRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAllInstructorsRequest {
    return { pagination: isSet(object.pagination) ? PaginationRequest.fromJSON(object.pagination) : undefined };
  },

  toJSON(message: GetAllInstructorsRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PaginationRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAllInstructorsRequest>, I>>(base?: I): GetAllInstructorsRequest {
    return GetAllInstructorsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAllInstructorsRequest>, I>>(object: I): GetAllInstructorsRequest {
    const message = createBaseGetAllInstructorsRequest();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PaginationRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseGetAllInstructorsResponse(): GetAllInstructorsResponse {
  return { success: undefined, error: undefined };
}

export const GetAllInstructorsResponse: MessageFns<GetAllInstructorsResponse> = {
  encode(message: GetAllInstructorsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== undefined) {
      AllInstructorsSuccess.encode(message.success, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAllInstructorsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllInstructorsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.success = AllInstructorsSuccess.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAllInstructorsResponse {
    return {
      success: isSet(object.success) ? AllInstructorsSuccess.fromJSON(object.success) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: GetAllInstructorsResponse): unknown {
    const obj: any = {};
    if (message.success !== undefined) {
      obj.success = AllInstructorsSuccess.toJSON(message.success);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAllInstructorsResponse>, I>>(base?: I): GetAllInstructorsResponse {
    return GetAllInstructorsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAllInstructorsResponse>, I>>(object: I): GetAllInstructorsResponse {
    const message = createBaseGetAllInstructorsResponse();
    message.success = (object.success !== undefined && object.success !== null)
      ? AllInstructorsSuccess.fromPartial(object.success)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    return message;
  },
};

function createBaseAllInstructorsSuccess(): AllInstructorsSuccess {
  return { instructors: [], pagination: undefined };
}

export const AllInstructorsSuccess: MessageFns<AllInstructorsSuccess> = {
  encode(message: AllInstructorsSuccess, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.instructors) {
      UserInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PaginationResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AllInstructorsSuccess {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAllInstructorsSuccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.instructors.push(UserInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PaginationResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AllInstructorsSuccess {
    return {
      instructors: globalThis.Array.isArray(object?.instructors)
        ? object.instructors.map((e: any) => UserInfo.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PaginationResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: AllInstructorsSuccess): unknown {
    const obj: any = {};
    if (message.instructors?.length) {
      obj.instructors = message.instructors.map((e) => UserInfo.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PaginationResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AllInstructorsSuccess>, I>>(base?: I): AllInstructorsSuccess {
    return AllInstructorsSuccess.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AllInstructorsSuccess>, I>>(object: I): AllInstructorsSuccess {
    const message = createBaseAllInstructorsSuccess();
    message.instructors = object.instructors?.map((e) => UserInfo.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PaginationResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

export type UserServiceService = typeof UserServiceService;
export const UserServiceService = {
  /** User Registration */
  registerUser: {
    path: "/user.UserService/RegisterUser",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RegisterUserRequest) => Buffer.from(RegisterUserRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => RegisterUserRequest.decode(value),
    responseSerialize: (value: RegisterUserResponse) => Buffer.from(RegisterUserResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => RegisterUserResponse.decode(value),
  },
  verifyUser: {
    path: "/user.UserService/VerifyUser",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: VerifyUserRequest) => Buffer.from(VerifyUserRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => VerifyUserRequest.decode(value),
    responseSerialize: (value: VerifyUserResponse) => Buffer.from(VerifyUserResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => VerifyUserResponse.decode(value),
  },
  /** User Login */
  loginUser: {
    path: "/user.UserService/LoginUser",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: LoginUserRequest) => Buffer.from(LoginUserRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => LoginUserRequest.decode(value),
    responseSerialize: (value: LoginUserResponse) => Buffer.from(LoginUserResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => LoginUserResponse.decode(value),
  },
  /** Get New Refresh Token */
  getNewRefreshToken: {
    path: "/user.UserService/GetNewRefreshToken",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetNewRefreshTokenRequest) =>
      Buffer.from(GetNewRefreshTokenRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetNewRefreshTokenRequest.decode(value),
    responseSerialize: (value: GetNewRefreshTokenResponse) =>
      Buffer.from(GetNewRefreshTokenResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetNewRefreshTokenResponse.decode(value),
  },
  /** Forgot Password */
  forgotPassword: {
    path: "/user.UserService/ForgotPassword",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ForgotPasswordRequest) => Buffer.from(ForgotPasswordRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ForgotPasswordRequest.decode(value),
    responseSerialize: (value: ForgotPasswordResponse) => Buffer.from(ForgotPasswordResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ForgotPasswordResponse.decode(value),
  },
  /** Update User Details */
  updateUserDetails: {
    path: "/user.UserService/UpdateUserDetails",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateUserDetailsRequest) => Buffer.from(UpdateUserDetailsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UpdateUserDetailsRequest.decode(value),
    responseSerialize: (value: UpdateUserDetailsResponse) =>
      Buffer.from(UpdateUserDetailsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => UpdateUserDetailsResponse.decode(value),
  },
  /** Change Password */
  changePassword: {
    path: "/user.UserService/ChangePassword",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ChangePasswordRequest) => Buffer.from(ChangePasswordRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ChangePasswordRequest.decode(value),
    responseSerialize: (value: ChangePasswordResponse) => Buffer.from(ChangePasswordResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ChangePasswordResponse.decode(value),
  },
  /** Get Wallet Transactions for a User (with pagination) */
  getWalletTransactions: {
    path: "/user.UserService/GetWalletTransactions",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetWalletTransactionsRequest) =>
      Buffer.from(GetWalletTransactionsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetWalletTransactionsRequest.decode(value),
    responseSerialize: (value: GetWalletTransactionsResponse) =>
      Buffer.from(GetWalletTransactionsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetWalletTransactionsResponse.decode(value),
  },
  /** Get All Users (with pagination) */
  getAllUsers: {
    path: "/user.UserService/GetAllUsers",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetAllUsersRequest) => Buffer.from(GetAllUsersRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetAllUsersRequest.decode(value),
    responseSerialize: (value: GetAllUsersResponse) => Buffer.from(GetAllUsersResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetAllUsersResponse.decode(value),
  },
  /** Get All Users emails */
  getAllUserEmails: {
    path: "/user.UserService/GetAllUserEmails",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetAllUserEmailsRequest) => Buffer.from(GetAllUserEmailsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetAllUserEmailsRequest.decode(value),
    responseSerialize: (value: GetAllUserEmailsResponse) =>
      Buffer.from(GetAllUserEmailsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetAllUserEmailsResponse.decode(value),
  },
  /** Get All Users emails */
  checkUserEmailExist: {
    path: "/user.UserService/CheckUserEmailExist",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CheckUserByEmailRequest) => Buffer.from(CheckUserByEmailRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CheckUserByEmailRequest.decode(value),
    responseSerialize: (value: CheckUserByEmailResponse) =>
      Buffer.from(CheckUserByEmailResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CheckUserByEmailResponse.decode(value),
  },
  /** Get Details About a Particular User by ID */
  getUserById: {
    path: "/user.UserService/GetUserById",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetUserByIdRequest) => Buffer.from(GetUserByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetUserByIdRequest.decode(value),
    responseSerialize: (value: GetUserByIdResponse) => Buffer.from(GetUserByIdResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetUserByIdResponse.decode(value),
  },
  /** Block/Unblock a User */
  blockUser: {
    path: "/user.UserService/BlockUser",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: BlockUserRequest) => Buffer.from(BlockUserRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => BlockUserRequest.decode(value),
    responseSerialize: (value: BlockUserResponse) => Buffer.from(BlockUserResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => BlockUserResponse.decode(value),
  },
  /** Get All Instructors (with pagination) */
  getAllInstructors: {
    path: "/user.UserService/GetAllInstructors",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetAllInstructorsRequest) => Buffer.from(GetAllInstructorsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetAllInstructorsRequest.decode(value),
    responseSerialize: (value: GetAllInstructorsResponse) =>
      Buffer.from(GetAllInstructorsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetAllInstructorsResponse.decode(value),
  },
} as const;

export interface UserServiceServer extends UntypedServiceImplementation {
  /** User Registration */
  registerUser: handleUnaryCall<RegisterUserRequest, RegisterUserResponse>;
  verifyUser: handleUnaryCall<VerifyUserRequest, VerifyUserResponse>;
  /** User Login */
  loginUser: handleUnaryCall<LoginUserRequest, LoginUserResponse>;
  /** Get New Refresh Token */
  getNewRefreshToken: handleUnaryCall<GetNewRefreshTokenRequest, GetNewRefreshTokenResponse>;
  /** Forgot Password */
  forgotPassword: handleUnaryCall<ForgotPasswordRequest, ForgotPasswordResponse>;
  /** Update User Details */
  updateUserDetails: handleUnaryCall<UpdateUserDetailsRequest, UpdateUserDetailsResponse>;
  /** Change Password */
  changePassword: handleUnaryCall<ChangePasswordRequest, ChangePasswordResponse>;
  /** Get Wallet Transactions for a User (with pagination) */
  getWalletTransactions: handleUnaryCall<GetWalletTransactionsRequest, GetWalletTransactionsResponse>;
  /** Get All Users (with pagination) */
  getAllUsers: handleUnaryCall<GetAllUsersRequest, GetAllUsersResponse>;
  /** Get All Users emails */
  getAllUserEmails: handleUnaryCall<GetAllUserEmailsRequest, GetAllUserEmailsResponse>;
  /** Get All Users emails */
  checkUserEmailExist: handleUnaryCall<CheckUserByEmailRequest, CheckUserByEmailResponse>;
  /** Get Details About a Particular User by ID */
  getUserById: handleUnaryCall<GetUserByIdRequest, GetUserByIdResponse>;
  /** Block/Unblock a User */
  blockUser: handleUnaryCall<BlockUserRequest, BlockUserResponse>;
  /** Get All Instructors (with pagination) */
  getAllInstructors: handleUnaryCall<GetAllInstructorsRequest, GetAllInstructorsResponse>;
}

export interface UserServiceClient extends Client {
  /** User Registration */
  registerUser(
    request: RegisterUserRequest,
    callback: (error: ServiceError | null, response: RegisterUserResponse) => void,
  ): ClientUnaryCall;
  registerUser(
    request: RegisterUserRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: RegisterUserResponse) => void,
  ): ClientUnaryCall;
  registerUser(
    request: RegisterUserRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: RegisterUserResponse) => void,
  ): ClientUnaryCall;
  verifyUser(
    request: VerifyUserRequest,
    callback: (error: ServiceError | null, response: VerifyUserResponse) => void,
  ): ClientUnaryCall;
  verifyUser(
    request: VerifyUserRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: VerifyUserResponse) => void,
  ): ClientUnaryCall;
  verifyUser(
    request: VerifyUserRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: VerifyUserResponse) => void,
  ): ClientUnaryCall;
  /** User Login */
  loginUser(
    request: LoginUserRequest,
    callback: (error: ServiceError | null, response: LoginUserResponse) => void,
  ): ClientUnaryCall;
  loginUser(
    request: LoginUserRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: LoginUserResponse) => void,
  ): ClientUnaryCall;
  loginUser(
    request: LoginUserRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: LoginUserResponse) => void,
  ): ClientUnaryCall;
  /** Get New Refresh Token */
  getNewRefreshToken(
    request: GetNewRefreshTokenRequest,
    callback: (error: ServiceError | null, response: GetNewRefreshTokenResponse) => void,
  ): ClientUnaryCall;
  getNewRefreshToken(
    request: GetNewRefreshTokenRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetNewRefreshTokenResponse) => void,
  ): ClientUnaryCall;
  getNewRefreshToken(
    request: GetNewRefreshTokenRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetNewRefreshTokenResponse) => void,
  ): ClientUnaryCall;
  /** Forgot Password */
  forgotPassword(
    request: ForgotPasswordRequest,
    callback: (error: ServiceError | null, response: ForgotPasswordResponse) => void,
  ): ClientUnaryCall;
  forgotPassword(
    request: ForgotPasswordRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ForgotPasswordResponse) => void,
  ): ClientUnaryCall;
  forgotPassword(
    request: ForgotPasswordRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ForgotPasswordResponse) => void,
  ): ClientUnaryCall;
  /** Update User Details */
  updateUserDetails(
    request: UpdateUserDetailsRequest,
    callback: (error: ServiceError | null, response: UpdateUserDetailsResponse) => void,
  ): ClientUnaryCall;
  updateUserDetails(
    request: UpdateUserDetailsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: UpdateUserDetailsResponse) => void,
  ): ClientUnaryCall;
  updateUserDetails(
    request: UpdateUserDetailsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: UpdateUserDetailsResponse) => void,
  ): ClientUnaryCall;
  /** Change Password */
  changePassword(
    request: ChangePasswordRequest,
    callback: (error: ServiceError | null, response: ChangePasswordResponse) => void,
  ): ClientUnaryCall;
  changePassword(
    request: ChangePasswordRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ChangePasswordResponse) => void,
  ): ClientUnaryCall;
  changePassword(
    request: ChangePasswordRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ChangePasswordResponse) => void,
  ): ClientUnaryCall;
  /** Get Wallet Transactions for a User (with pagination) */
  getWalletTransactions(
    request: GetWalletTransactionsRequest,
    callback: (error: ServiceError | null, response: GetWalletTransactionsResponse) => void,
  ): ClientUnaryCall;
  getWalletTransactions(
    request: GetWalletTransactionsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetWalletTransactionsResponse) => void,
  ): ClientUnaryCall;
  getWalletTransactions(
    request: GetWalletTransactionsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetWalletTransactionsResponse) => void,
  ): ClientUnaryCall;
  /** Get All Users (with pagination) */
  getAllUsers(
    request: GetAllUsersRequest,
    callback: (error: ServiceError | null, response: GetAllUsersResponse) => void,
  ): ClientUnaryCall;
  getAllUsers(
    request: GetAllUsersRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetAllUsersResponse) => void,
  ): ClientUnaryCall;
  getAllUsers(
    request: GetAllUsersRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetAllUsersResponse) => void,
  ): ClientUnaryCall;
  /** Get All Users emails */
  getAllUserEmails(
    request: GetAllUserEmailsRequest,
    callback: (error: ServiceError | null, response: GetAllUserEmailsResponse) => void,
  ): ClientUnaryCall;
  getAllUserEmails(
    request: GetAllUserEmailsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetAllUserEmailsResponse) => void,
  ): ClientUnaryCall;
  getAllUserEmails(
    request: GetAllUserEmailsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetAllUserEmailsResponse) => void,
  ): ClientUnaryCall;
  /** Get All Users emails */
  checkUserEmailExist(
    request: CheckUserByEmailRequest,
    callback: (error: ServiceError | null, response: CheckUserByEmailResponse) => void,
  ): ClientUnaryCall;
  checkUserEmailExist(
    request: CheckUserByEmailRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CheckUserByEmailResponse) => void,
  ): ClientUnaryCall;
  checkUserEmailExist(
    request: CheckUserByEmailRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CheckUserByEmailResponse) => void,
  ): ClientUnaryCall;
  /** Get Details About a Particular User by ID */
  getUserById(
    request: GetUserByIdRequest,
    callback: (error: ServiceError | null, response: GetUserByIdResponse) => void,
  ): ClientUnaryCall;
  getUserById(
    request: GetUserByIdRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetUserByIdResponse) => void,
  ): ClientUnaryCall;
  getUserById(
    request: GetUserByIdRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetUserByIdResponse) => void,
  ): ClientUnaryCall;
  /** Block/Unblock a User */
  blockUser(
    request: BlockUserRequest,
    callback: (error: ServiceError | null, response: BlockUserResponse) => void,
  ): ClientUnaryCall;
  blockUser(
    request: BlockUserRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: BlockUserResponse) => void,
  ): ClientUnaryCall;
  blockUser(
    request: BlockUserRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: BlockUserResponse) => void,
  ): ClientUnaryCall;
  /** Get All Instructors (with pagination) */
  getAllInstructors(
    request: GetAllInstructorsRequest,
    callback: (error: ServiceError | null, response: GetAllInstructorsResponse) => void,
  ): ClientUnaryCall;
  getAllInstructors(
    request: GetAllInstructorsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetAllInstructorsResponse) => void,
  ): ClientUnaryCall;
  getAllInstructors(
    request: GetAllInstructorsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetAllInstructorsResponse) => void,
  ): ClientUnaryCall;
}

export const UserServiceClient = makeGenericClientConstructor(UserServiceService, "user.UserService") as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): UserServiceClient;
  service: typeof UserServiceService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
